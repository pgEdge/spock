SELECT * FROM spock_regress_variables()
\gset
\c :provider_dsn
CREATE USER super2 SUPERUSER;
\c :subscriber_dsn
SELECT * FROM spock.node_add_interface('test_provider', 'super2', (SELECT provider_dsn FROM spock_regress_variables()) || ' user=super2');
 node_add_interface 
--------------------
         1679954453
(1 row)

-- Check that the signal_worker_xact_callback routine process subscription
-- change in a right way, considering abortion and prepared transactions.
BEGIN;
SELECT * FROM spock.sub_alter_interface('test_subscription', 'super2');
 sub_alter_interface 
---------------------
 t
(1 row)

ROLLBACK;
BEGIN;
SELECT * FROM spock.sub_alter_interface('test_subscription', 'super2');
 sub_alter_interface 
---------------------
 t
(1 row)

PREPARE TRANSACTION 't1';
ABORT PREPARED 't1'; -- ERROR between preparation and abortion
ERROR:  syntax error at or near "PREPARED"
LINE 1: ABORT PREPARED 't1';
              ^
ROLLBACK PREPARED 't1';
BEGIN;
SAVEPOINT s1;
SELECT * FROM spock.sub_alter_interface('test_subscription', 'super2');
 sub_alter_interface 
---------------------
 t
(1 row)

ROLLBACK TO SAVEPOINT s1;
COMMIT;
SELECT * FROM spock.sub_alter_interface('test_subscription', 'super2');
 sub_alter_interface 
---------------------
 t
(1 row)

DO $$
BEGIN
    WHILE EXISTS (SELECT 1 FROM spock.sub_show_status() WHERE status = 'down')
	LOOP
    END LOOP;
END;$$;
SELECT
  subscription_name, status, provider_node, replication_sets, forward_origins
FROM spock.sub_show_status();
 subscription_name |   status    | provider_node |           replication_sets            | forward_origins 
-------------------+-------------+---------------+---------------------------------------+-----------------
 test_subscription | replicating | test_provider | {default,default_insert_only,ddl_sql} | 
(1 row)

\c :provider_dsn
DO $$
BEGIN
    WHILE EXISTS (SELECT 1 FROM pg_replication_slots WHERE active = 'false')
	LOOP
    END LOOP;
END;$$;
SELECT plugin, slot_type, active FROM pg_replication_slots;
    plugin    | slot_type | active 
--------------+-----------+--------
 spock_output | logical   | t
(1 row)

SELECT usename FROM pg_stat_replication WHERE application_name = 'test_subscription';
 usename 
---------
(0 rows)

\c :subscriber_dsn
SELECT * FROM spock.sub_alter_interface('test_subscription', 'test_provider');
 sub_alter_interface 
---------------------
 t
(1 row)

DO $$
BEGIN
    WHILE EXISTS (SELECT 1 FROM spock.sub_show_status() WHERE status = 'down')
	LOOP
	-- TODO: The multimaster testing buildfarm should have a general parameter
	-- like 'wait_change_timeout' that may be used to take control over infinite
	-- waiting cycles.
    END LOOP;
END;$$;
SELECT
  subscription_name, status, provider_node, replication_sets, forward_origins
FROM spock.sub_show_status();
 subscription_name |   status    | provider_node |           replication_sets            | forward_origins 
-------------------+-------------+---------------+---------------------------------------+-----------------
 test_subscription | replicating | test_provider | {default,default_insert_only,ddl_sql} | 
(1 row)

\c :provider_dsn
DROP USER super2;
-- Creation of a slot needs some time. Just wait.
DO $$
BEGIN
    WHILE EXISTS (SELECT 1 FROM pg_replication_slots WHERE active = 'false')
	LOOP
    END LOOP;
END;$$;
SELECT plugin, slot_type, active FROM pg_replication_slots;
    plugin    | slot_type | active 
--------------+-----------+--------
 spock_output | logical   | t
(1 row)

SELECT usename FROM pg_stat_replication WHERE application_name = 'test_subscription';
 usename 
---------
(0 rows)

