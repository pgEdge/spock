--Tuple Origin
SELECT * FROM spock_regress_variables()
\gset
-- This is to ensure that the test runs with the correct configuration
\c :provider_dsn
ALTER SYSTEM SET spock.enable_ddl_replication = 'on';
ALTER SYSTEM SET spock.include_ddl_repset = 'on';
ALTER SYSTEM SET spock.allow_ddl_from_functions = 'on';
SELECT pg_reload_conf();
 pg_reload_conf 
----------------
 t
(1 row)

\c :provider_dsn
-- Create schema with tables on provider (node 1)
CREATE SCHEMA hollywood
    CREATE TABLE films (title text, release date, awards text[])
    CREATE TABLE shorts (title text, release date, awards text[]);
INFO:  DDL statement replicated.
-- Create a test table on provider (node 1)
CREATE TABLE test1 (id int primary key, name text);
INFO:  DDL statement replicated.
-- Create a function that creates two tables when called on provider (node 1)
CREATE FUNCTION auto_ddl_test() RETURNS void AS $func$
BEGIN
    EXECUTE 'CREATE TABLE test2 (id int primary key, name text)';
    EXECUTE 'CREATE TABLE test3 (id int primary key, name text)';
END;
$func$ LANGUAGE plpgsql;
INFO:  DDL statement replicated.
-- Call function to create tables test2 and test3
SELECT auto_ddl_test();
INFO:  DDL statement replicated.
INFO:  DDL statement replicated.
 auto_ddl_test 
---------------
 
(1 row)

INSERT INTO test1 VALUES (1, 'one'), (2, 'two');
-- Generate a sync event
SELECT spock.sync_event() as sync_event
\gset
\c :subscriber_dsn
-- Wait for sync event to be processed on subscriber (node 2)
CALL spock.wait_for_sync_event(true, 'test_provider', :'sync_event');
 result 
--------
 t
(1 row)

-- Check schema, table and function appear on subscriber (node 2)
SELECT count(*) FROM spock.tables where nspname = 'hollywood' AND set_name IS NOT NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM spock.tables where relname = 'test1' AND set_name IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM spock.tables where (relname = 'test2' or relname = 'test3') AND set_name IS NOT NULL;
 count 
-------
     2
(1 row)

-- auto-ddl and transaction state: check that auto-ddl initiates a new
-- transaction if it is not inside one.
CREATE TABLE test_380 (x serial PRIMARY KEY, y integer);
INFO:  DDL statement replicated.
CREATE INDEX test_380_y_idx ON test_380 (y);
INFO:  DDL statement replicated.
ALTER TABLE test_380 CLUSTER ON test_380_y_idx;
INFO:  DDL statement replicated.
CLUSTER; -- Should call utility hook outside of transaction state
INFO:  DDL statement replicated.
DROP TABLE test_380 CASCADE;
NOTICE:  drop cascades to table test_380 membership in replication set default
INFO:  DDL statement replicated.
-- Reset the configuration to the default value
\c :provider_dsn
ALTER SYSTEM SET spock.enable_ddl_replication = 'off';
WARNING:  This DDL statement will not be replicated.
ALTER SYSTEM SET spock.include_ddl_repset = 'off';
WARNING:  This DDL statement will not be replicated.
ALTER SYSTEM SET spock.allow_ddl_from_functions = 'off';
WARNING:  This DDL statement will not be replicated.
SELECT pg_reload_conf();
 pg_reload_conf 
----------------
 t
(1 row)

