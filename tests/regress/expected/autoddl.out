--Tuple Origin
SELECT * FROM spock_regress_variables()
\gset
-- This is to ensure that the test runs with the correct configuration
\c :provider_dsn
ALTER SYSTEM SET spock.enable_ddl_replication = 'on';
ALTER SYSTEM SET spock.include_ddl_repset = 'on';
ALTER SYSTEM SET spock.allow_ddl_from_functions = 'on';
SELECT pg_reload_conf();
 pg_reload_conf 
----------------
 t
(1 row)

\c :provider_dsn
-- Create schema with tables on provider (node 1)
CREATE SCHEMA hollywood
    CREATE TABLE films (title text, release date, awards text[])
    CREATE TABLE shorts (title text, release date, awards text[]);
INFO:  DDL statement replicated.
-- Create a test table on provider (node 1)
CREATE TABLE test1 (id int primary key, name text);
INFO:  DDL statement replicated.
-- Create a function that creates two tables when called on provider (node 1)
CREATE FUNCTION auto_ddl_test() RETURNS void AS $func$
BEGIN
    EXECUTE 'CREATE TABLE test2 (id int primary key, name text)';
    EXECUTE 'CREATE TABLE test3 (id int primary key, name text)';
END;
$func$ LANGUAGE plpgsql;
INFO:  DDL statement replicated.
-- Call function to create tables test2 and test3
SELECT auto_ddl_test();
INFO:  DDL statement replicated.
INFO:  DDL statement replicated.
 auto_ddl_test 
---------------
 
(1 row)

INSERT INTO test1 VALUES (1, 'one'), (2, 'two');
-- Generate a sync event
SELECT spock.sync_event() as sync_event
\gset
\c :subscriber_dsn
-- Wait for sync event to be processed on subscriber (node 2)
CALL spock.wait_for_sync_event(true, 'test_provider', :'sync_event');
 result 
--------
 t
(1 row)

-- Check schema, table and function appear on subscriber (node 2)
SELECT count(*) FROM spock.tables where nspname = 'hollywood' AND set_name IS NOT NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM spock.tables where relname = 'test1' AND set_name IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM spock.tables where (relname = 'test2' or relname = 'test3') AND set_name IS NOT NULL;
 count 
-------
     2
(1 row)

\c :provider_dsn
-- auto-ddl and transaction state: check that auto-ddl initiates a new
-- transaction if it is not inside one.
CREATE TABLE test_380 (x serial PRIMARY KEY, y integer);
INFO:  DDL statement replicated.
CREATE INDEX test_380_y_idx ON test_380 (y);
INFO:  DDL statement replicated.
ALTER TABLE test_380 CLUSTER ON test_380_y_idx;
INFO:  DDL statement replicated.
CLUSTER; -- Do not replicate
WARNING:  This DDL statement will not be replicated.
CLUSTER test_380 USING test_380_y_idx; -- Replicate
INFO:  DDL statement replicated.
DROP TABLE test_380 CASCADE;
NOTICE:  drop cascades to table test_380 membership in replication set default
INFO:  DDL statement replicated.
-- CLUSTER on partitioned table can't be performed inside a transaction.
-- Check this special use case.
CREATE TABLE test_383 (a int) PARTITION BY RANGE (a);
INFO:  DDL statement replicated.
CREATE TABLE test_383_1 PARTITION OF clstrpart FOR VALUES FROM (1) TO (10);
ERROR:  relation "clstrpart" does not exist
CREATE TABLE test_383_2 PARTITION OF clstrpart1 FOR VALUES FROM (1) TO (5);
ERROR:  relation "clstrpart1" does not exist
CREATE INDEX test_383_y_idx ON test_383 (a);
INFO:  DDL statement replicated.
CLUSTER test_383 USING test_383_y_idx; -- Should not be replicated
WARNING:  This DDL statement will not be replicated.
DROP TABLE test_383 CASCADE;
NOTICE:  drop cascades to table test_383 membership in replication set default_insert_only
INFO:  DDL statement replicated.
\c :provider_dsn
\set VERBOSITY terse
-- Check propagation of security labels
CREATE TABLE slabel1 (x integer NOT NULL, y text PRIMARY KEY);
INFO:  DDL statement replicated.
SELECT spock.delta_apply('slabel1', 'x');
INFO:  DDL statement replicated.
INFO:  DDL statement replicated.
 delta_apply 
-------------
 t
(1 row)

SELECT spock.delta_apply('slabel1', 'y'); -- ERROR
ERROR:  type "text" can not be used in delta_apply conflict resolution
SELECT spock.delta_apply('slabel1', 'z'); -- ERROR
ERROR:  column z does not exist in the table slabel1
SELECT spock.delta_apply('slabel1', 'x'); -- repeating call do nothing
INFO:  DDL statement replicated.
INFO:  DDL statement replicated.
 delta_apply 
-------------
 t
(1 row)

SELECT objname, label FROM pg_seclabels;
  objname  |       label       
-----------+-------------------
 slabel1.x | spock.delta_apply
(1 row)

-- Short round trip to check that subscriber has the security label
\c :subscriber_dsn
SELECT objname, label FROM pg_seclabels;
  objname  |       label       
-----------+-------------------
 slabel1.x | spock.delta_apply
(1 row)

\c :provider_dsn
SELECT spock.delta_apply('slabel1', 'x', true);
INFO:  DDL statement replicated.
INFO:  DDL statement replicated.
 delta_apply 
-------------
 t
(1 row)

-- Short round trip to check that subscriber has removed the security label too
\c :subscriber_dsn
SELECT objname, label FROM pg_seclabels;
 objname | label 
---------+-------
(0 rows)

\c :provider_dsn
-- Reset the configuration to the default value
ALTER SYSTEM SET spock.enable_ddl_replication = 'off';
WARNING:  This DDL statement will not be replicated.
ALTER SYSTEM SET spock.include_ddl_repset = 'off';
WARNING:  This DDL statement will not be replicated.
ALTER SYSTEM SET spock.allow_ddl_from_functions = 'off';
WARNING:  This DDL statement will not be replicated.
SELECT pg_reload_conf();
 pg_reload_conf 
----------------
 t
(1 row)

