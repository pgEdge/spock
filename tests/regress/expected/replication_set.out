/* First test whether a table's replication set can be properly manipulated */
SELECT * FROM spock_regress_variables()
\gset
\c :provider_dsn
SELECT spock.replicate_ddl($$
CREATE SCHEMA normalschema;
CREATE SCHEMA "strange.schema-IS";
CREATE TABLE public.test_publicschema(id serial primary key, data text);
CREATE TABLE normalschema.test_normalschema(id serial primary key);
CREATE TABLE "strange.schema-IS".test_strangeschema(id serial primary key);
CREATE TABLE public.test_nopkey(id int);
CREATE UNLOGGED TABLE public.test_unlogged(id int primary key);
$$);
 replicate_ddl 
---------------
 t
(1 row)

SELECT nspname, relname, set_name FROM spock.tables
 WHERE relname IN ('test_publicschema', 'test_normalschema', 'test_strangeschema', 'test_nopkey') ORDER BY 1,2,3;
      nspname      |      relname       | set_name 
-------------------+--------------------+----------
 normalschema      | test_normalschema  | 
 public            | test_nopkey        | 
 public            | test_publicschema  | 
 strange.schema-IS | test_strangeschema | 
(4 rows)

SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

-- show initial replication sets
SELECT nspname, relname, set_name FROM spock.tables
 WHERE relname IN ('test_publicschema', 'test_normalschema', 'test_strangeschema', 'test_nopkey') ORDER BY 1,2,3;
      nspname      |      relname       | set_name 
-------------------+--------------------+----------
 normalschema      | test_normalschema  | 
 public            | test_nopkey        | 
 public            | test_publicschema  | 
 strange.schema-IS | test_strangeschema | 
(4 rows)

-- not existing replication set
SELECT * FROM spock.repset_add_table('nonexisting', 'test_publicschema');
ERROR:  replication set nonexisting not found
-- create some replication sets
SELECT * FROM spock.repset_create('repset_replicate_all');
 repset_create 
---------------
    2353314786
(1 row)

SELECT * FROM spock.repset_create('repset_replicate_instrunc', replicate_update := false, replicate_delete := false);
 repset_create 
---------------
    1585236067
(1 row)

SELECT * FROM spock.repset_create('repset_replicate_insupd', replicate_delete := false, replicate_truncate := false);
 repset_create 
---------------
     384626605
(1 row)

-- add tables
SELECT * FROM spock.repset_add_table('repset_replicate_all', 'test_publicschema');
 repset_add_table 
------------------
 t
(1 row)

SELECT * FROM spock.repset_add_table('repset_replicate_instrunc', 'normalschema.test_normalschema');
 repset_add_table 
------------------
 t
(1 row)

SELECT * FROM spock.repset_add_table('repset_replicate_insupd', 'normalschema.test_normalschema');
 repset_add_table 
------------------
 t
(1 row)

SELECT * FROM spock.repset_add_table('repset_replicate_insupd', '"strange.schema-IS".test_strangeschema');
 repset_add_table 
------------------
 t
(1 row)

-- should fail
SELECT * FROM spock.repset_add_table('repset_replicate_all', 'test_unlogged');
ERROR:  UNLOGGED and TEMP tables cannot be replicated
SELECT * FROM spock.repset_add_table('repset_replicate_all', 'test_nopkey');
ERROR:  table test_nopkey cannot be added to replication set repset_replicate_all
DETAIL:  table does not have PRIMARY KEY and given replication set is configured to replicate UPDATEs and/or DELETEs
HINT:  Add a PRIMARY KEY to the table
-- success
SELECT * FROM spock.repset_add_table('repset_replicate_instrunc', 'test_nopkey');
 repset_add_table 
------------------
 t
(1 row)

SELECT * FROM spock.repset_alter('repset_replicate_insupd', replicate_truncate := true);
 repset_alter 
--------------
    384626605
(1 row)

-- fail again
SELECT * FROM spock.repset_add_table('repset_replicate_insupd', 'test_nopkey');
ERROR:  table test_nopkey cannot be added to replication set repset_replicate_insupd
DETAIL:  table does not have PRIMARY KEY and given replication set is configured to replicate UPDATEs and/or DELETEs
HINT:  Add a PRIMARY KEY to the table
SELECT * FROM spock.repset_add_all_tables('default', '{public}');
ERROR:  table test_nopkey cannot be added to replication set default
DETAIL:  table does not have PRIMARY KEY and given replication set is configured to replicate UPDATEs and/or DELETEs
HINT:  Add a PRIMARY KEY to the table
SELECT * FROM spock.repset_alter('repset_replicate_instrunc', replicate_update := true);
ERROR:  replication set repset_replicate_instrunc cannot be altered to replicate UPDATEs or DELETEs because it contains tables without PRIMARY KEY
SELECT * FROM spock.repset_alter('repset_replicate_instrunc', replicate_delete := true);
ERROR:  replication set repset_replicate_instrunc cannot be altered to replicate UPDATEs or DELETEs because it contains tables without PRIMARY KEY
-- Adding already-added fails
\set VERBOSITY terse
SELECT * FROM spock.repset_add_table('repset_replicate_all', 'public.test_publicschema');
ERROR:  duplicate key value violates unique constraint "replication_set_table_pkey"
\set VERBOSITY default
-- check the replication sets
SELECT nspname, relname, set_name FROM spock.tables
 WHERE relname IN ('test_publicschema', 'test_normalschema', 'test_strangeschema', 'test_nopkey') ORDER BY 1,2,3;
      nspname      |      relname       |         set_name          
-------------------+--------------------+---------------------------
 normalschema      | test_normalschema  | repset_replicate_instrunc
 normalschema      | test_normalschema  | repset_replicate_insupd
 public            | test_nopkey        | repset_replicate_instrunc
 public            | test_publicschema  | repset_replicate_all
 strange.schema-IS | test_strangeschema | repset_replicate_insupd
(5 rows)

SELECT * FROM spock.repset_add_all_tables('default_insert_only', '{public}');
 repset_add_all_tables 
-----------------------
 t
(1 row)

SELECT nspname, relname, set_name FROM spock.tables
 WHERE relname IN ('test_publicschema', 'test_normalschema', 'test_strangeschema', 'test_nopkey') ORDER BY 1,2,3;
      nspname      |      relname       |         set_name          
-------------------+--------------------+---------------------------
 normalschema      | test_normalschema  | repset_replicate_instrunc
 normalschema      | test_normalschema  | repset_replicate_insupd
 public            | test_nopkey        | default_insert_only
 public            | test_nopkey        | repset_replicate_instrunc
 public            | test_publicschema  | default_insert_only
 public            | test_publicschema  | repset_replicate_all
 strange.schema-IS | test_strangeschema | repset_replicate_insupd
(7 rows)

--too short
SELECT spock.repset_create('');
ERROR:  replication set name cannot be empty
-- Can't drop table while it's in a repset
DROP TABLE public.test_publicschema;
ERROR:  cannot drop table test_publicschema because other objects depend on it
DETAIL:  table test_publicschema membership in replication set default_insert_only depends on table test_publicschema
table test_publicschema membership in replication set repset_replicate_all depends on table test_publicschema
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-- Can't drop table while it's in a repset
BEGIN;
SELECT spock.replicate_ddl($$
DROP TABLE public.test_publicschema;
$$);
ERROR:  cannot drop table test_publicschema because other objects depend on it
DETAIL:  table test_publicschema membership in replication set default_insert_only depends on table test_publicschema
table test_publicschema membership in replication set repset_replicate_all depends on table test_publicschema
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
CONTEXT:  during execution of queued SQL statement: 
DROP TABLE public.test_publicschema;

ROLLBACK;
-- Can CASCADE though, even outside ddlrep
BEGIN;
DROP TABLE public.test_publicschema CASCADE;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to table test_publicschema membership in replication set default_insert_only
drop cascades to table test_publicschema membership in replication set repset_replicate_all
ROLLBACK;
-- ... and can drop after repset removal
SELECT spock.repset_remove_table('repset_replicate_all', 'public.test_publicschema');
 repset_remove_table 
---------------------
 t
(1 row)

SELECT spock.repset_remove_table('default_insert_only', 'public.test_publicschema');
 repset_remove_table 
---------------------
 t
(1 row)

BEGIN;
DROP TABLE public.test_publicschema;
ROLLBACK;
\set VERBOSITY terse
SELECT spock.replicate_ddl($$
	DROP TABLE public.test_publicschema CASCADE;
	DROP SCHEMA normalschema CASCADE;
	DROP SCHEMA "strange.schema-IS" CASCADE;
	DROP TABLE public.test_nopkey CASCADE;
	DROP TABLE public.test_unlogged CASCADE;
$$);
NOTICE:  drop cascades to table normalschema.test_normalschema
NOTICE:  drop cascades to 2 other objects
NOTICE:  drop cascades to table "strange.schema-IS".test_strangeschema
NOTICE:  drop cascades to table "strange.schema-IS".test_strangeschema membership in replication set repset_replicate_insupd
NOTICE:  drop cascades to 2 other objects
 replicate_ddl 
---------------
 t
(1 row)

\c :subscriber_dsn
SELECT * FROM spock.replication_set;
   set_id   | set_nodeid |      set_name       | replicate_insert | replicate_update | replicate_delete | replicate_truncate 
------------+------------+---------------------+------------------+------------------+------------------+--------------------
 1814541545 |      52665 | default             | t                | t                | t                | t
 1909385617 |      52665 | default_insert_only | t                | f                | f                | t
 2586246310 |      52665 | ddl_sql             | t                | f                | f                | f
(3 rows)

-- Issue SPOC-102
-- Being on subscriber, set the exception behaviour to transdiscard
ALTER SYSTEM SET spock.exception_behaviour = 'transdiscard';
SELECT pg_reload_conf();
 pg_reload_conf 
----------------
 t
(1 row)

\c :provider_dsn
 -- Table spoc_102g must be on each node and inside the replication set.
SELECT spock.replicate_ddl('CREATE TABLE spoc_102g (x integer PRIMARY KEY);');
 replicate_ddl 
---------------
 t
(1 row)

SELECT spock.repset_add_table('default', 'spoc_102g');
 repset_add_table 
------------------
 t
(1 row)

-- Must be disabled
SHOW spock.enable_ddl_replication;
 spock.enable_ddl_replication 
------------------------------
 off
(1 row)

SHOW spock.include_ddl_repset;
 spock.include_ddl_repset 
--------------------------
 off
(1 row)

CREATE TABLE spoc_102l (x integer PRIMARY KEY); -- local for the publisher
INSERT INTO spoc_102l VALUES (1); -- Should be invisible for the subscriber node.
INSERT INTO spoc_102g VALUES (-1);
SELECT spock.repset_add_table('default', 'spoc_102l');
 repset_add_table 
------------------
 t
(1 row)

INSERT INTO spoc_102g VALUES (-2);
INSERT INTO spoc_102l VALUES (2); -- Should cause an error that will be just skipped
INSERT INTO spoc_102g VALUES (-3);
BEGIN; -- All its changes must be skipped
INSERT INTO spoc_102l VALUES (3);
INSERT INTO spoc_102g VALUES (-4); -- NOT replicated
END;
INSERT INTO spoc_102g VALUES (-5);
\c :subscriber_dsn
-- Check replication state before the problem fixation
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

SELECT * FROM spoc_102g ORDER BY x;
 x  
----
 -5
 -3
 -2
 -1
(4 rows)

SELECT * FROM spoc_102l ORDER BY x; -- ERROR, does not exist yet
ERROR:  relation "spoc_102l" does not exist at character 15
-- Now, fix the issue with absent table
BEGIN;
SELECT spock.repair_mode(true) \gset
CREATE TABLE spoc_102l (x integer PRIMARY KEY);
END;
-- Check that replication works
INSERT INTO spoc_102l VALUES (4);
-- XXX: Why we don't synchronize the state of the table and don't see rows
-- publisher has added before?
SELECT * FROM spoc_102l ORDER BY x;
 x 
---
 4
(1 row)

-- Return to provider and check that it doesn't see value (4).
-- Afterwards, add value 5 that must be replicated
\c :provider_dsn
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

SELECT * FROM spoc_102l ORDER BY x;
 x 
---
 1
 2
 3
(3 rows)

INSERT INTO spoc_102l VALUES (5);
-- Re-check that subscription works properly
\c :subscriber_dsn
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

SELECT * FROM spoc_102l ORDER BY x;
 x 
---
 4
 5
(2 rows)

--
-- Now, let's check the 'discard' mode
--
ALTER SYSTEM SET spock.exception_behaviour = 'discard';
SELECT pg_reload_conf();
 pg_reload_conf 
----------------
 t
(1 row)

\c :provider_dsn
TRUNCATE spoc_102g;
SELECT spock.replicate_ddl('DROP TABLE spoc_102l CASCADE');
NOTICE:  drop cascades to table spoc_102l membership in replication set default
 replicate_ddl 
---------------
 t
(1 row)

CREATE TABLE spoc_102l (x integer PRIMARY KEY); -- local for the publisher
INSERT INTO spoc_102l VALUES (1);
INSERT INTO spoc_102g VALUES (-1);
SELECT spock.repset_add_table('default', 'spoc_102l');
 repset_add_table 
------------------
 t
(1 row)

INSERT INTO spoc_102g VALUES (-2);
INSERT INTO spoc_102l VALUES (2); -- table does not exist yet, skip
INSERT INTO spoc_102g VALUES (-3);
BEGIN; -- Skip INSERT to spoc_102l and apply INSERT to spoc_102g
INSERT INTO spoc_102l VALUES (3);
INSERT INTO spoc_102g VALUES (-4);
END;
INSERT INTO spoc_102g VALUES (-5);
\c :subscriber_dsn
-- Check replication state before the problem fixation
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

SELECT * FROM spoc_102g ORDER BY x;
 x  
----
 -5
 -4
 -3
 -2
 -1
(5 rows)

SELECT * FROM spoc_102l ORDER BY x; -- ERROR, does not exist yet
ERROR:  relation "spoc_102l" does not exist at character 15
-- Now, fix the issue with absent table. Use 'IF NOT EXISTS' hack to create
-- the table where it is absent.
\c :provider_dsn
SELECT spock.replicate_ddl('CREATE TABLE IF NOT EXISTS spoc_102l (x integer PRIMARY KEY)');
NOTICE:  relation "spoc_102l" already exists, skipping
 replicate_ddl 
---------------
 t
(1 row)

INSERT INTO spoc_102l VALUES (4);
INSERT INTO spoc_102g VALUES (-6);
\c :subscriber_dsn
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

SELECT * FROM spoc_102g ORDER BY x;
 x  
----
 -6
 -5
 -4
 -3
 -2
 -1
(6 rows)

SELECT * FROM spoc_102l ORDER BY x;
 x 
---
 4
(1 row)

-- Check exception log format
SELECT
  command_counter,table_schema,table_name,operation,
  remote_new_tup,error_message
FROM spock.exception_log
ORDER BY command_counter;
 command_counter | table_schema | table_name | operation |                   remote_new_tup                   |       error_message       
-----------------+--------------+------------+-----------+----------------------------------------------------+---------------------------
               1 |              |            | INSERT    |                                                    | Spock can't find relation
               2 |              |            | INSERT    |                                                    | Spock can't find relation
               3 | public       | spoc_102g  | INSERT    | [{"value": -4, "attname": "x", "atttype": "int4"}] | unknown
               4 |              |            | INSERT    |                                                    | Spock can't find relation
               5 |              |            | INSERT    |                                                    | Spock can't find relation
               6 | public       | spoc_102g  | INSERT    | [{"value": -4, "attname": "x", "atttype": "int4"}] | unknown
(6 rows)

\c :provider_dsn
SELECT spock.replicate_ddl('DROP TABLE IF EXISTS spoc_102g,spoc_102l CASCADE');
NOTICE:  drop cascades to table spoc_102g membership in replication set default
NOTICE:  drop cascades to table spoc_102l membership in replication set default
 replicate_ddl 
---------------
 t
(1 row)

--
-- UPDATE row of an absent relation
--
SELECT spock.replicate_ddl('CREATE TABLE spoc_102g_u (x integer PRIMARY KEY);');
 replicate_ddl 
---------------
 t
(1 row)

SELECT spock.repset_add_table('default', 'spoc_102g_u');
 repset_add_table 
------------------
 t
(1 row)

CREATE TABLE spoc_102l_u (x integer PRIMARY KEY); -- local for the publisher
INSERT INTO spoc_102l_u VALUES (1);
INSERT INTO spoc_102g_u VALUES (-1), (0);
SELECT spock.repset_add_table('default', 'spoc_102l_u');
 repset_add_table 
------------------
 t
(1 row)

UPDATE spoc_102g_u SET x = -2 WHERE x = -1;
UPDATE spoc_102l_u SET x = 2 WHERE x = 1;
BEGIN;
UPDATE spoc_102l_u SET x = 3 WHERE x = 2;
UPDATE spoc_102g_u SET x = -3 WHERE x = -2;
END;
UPDATE spoc_102g_u SET x = 1 WHERE x = 0;
\c :subscriber_dsn
-- Check replication state before the problem fixation
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

SELECT * FROM spoc_102g_u ORDER BY x;
 x  
----
 -3
  1
(2 rows)

SELECT * FROM spoc_102l_u ORDER BY x; -- ERROR, does not exist yet
ERROR:  relation "spoc_102l_u" does not exist at character 15
-- Now, fix the issue with absent table
\c :provider_dsn
SELECT spock.replicate_ddl('CREATE TABLE IF NOT EXISTS spoc_102l_u (x integer PRIMARY KEY)');
NOTICE:  relation "spoc_102l_u" already exists, skipping
 replicate_ddl 
---------------
 t
(1 row)

UPDATE spoc_102l_u SET x = -3 WHERE x = 3;
INSERT INTO spoc_102l_u VALUES (4);
UPDATE spoc_102l_u SET x = 5 WHERE x = 4;
-- Check that replication works
\c :subscriber_dsn
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

SELECT * FROM spoc_102l_u ORDER BY x;
 x 
---
 5
(1 row)

SELECT * FROM spoc_102g_u ORDER BY x;
 x  
----
 -3
  1
(2 rows)

SELECT
  command_counter,table_schema,table_name,operation,
  remote_new_tup,error_message
FROM spock.exception_log
ORDER BY command_counter;
 command_counter | table_schema | table_name  | operation |                   remote_new_tup                   |                                             error_message                                              
-----------------+--------------+-------------+-----------+----------------------------------------------------+--------------------------------------------------------------------------------------------------------
               1 |              |             | INSERT    |                                                    | Spock can't find relation
               2 |              |             | INSERT    |                                                    | Spock can't find relation
               3 | public       | spoc_102g   | INSERT    | [{"value": -4, "attname": "x", "atttype": "int4"}] | unknown
               4 |              |             | INSERT    |                                                    | Spock can't find relation
               5 |              |             | INSERT    |                                                    | Spock can't find relation
               6 | public       | spoc_102g   | INSERT    | [{"value": -4, "attname": "x", "atttype": "int4"}] | unknown
               7 |              |             | UPDATE    |                                                    | Spock can't find relation
               8 |              |             | UPDATE    |                                                    | Spock can't find relation
               9 | public       | spoc_102g_u | UPDATE    | [{"value": -3, "attname": "x", "atttype": "int4"}] | unknown
              10 | public       | spoc_102l_u | UPDATE    | [{"value": -3, "attname": "x", "atttype": "int4"}] | logical replication did not find row to be updated in replication target relation (public.spoc_102l_u)
(10 rows)

\c :provider_dsn
SELECT spock.replicate_ddl('DROP TABLE IF EXISTS spoc_102g_u,spoc_102l_u CASCADE');
NOTICE:  drop cascades to table spoc_102g_u membership in replication set default
NOTICE:  drop cascades to table spoc_102l_u membership in replication set default
 replicate_ddl 
---------------
 t
(1 row)

--
-- DELETE row from an absent relation
--
SELECT spock.replicate_ddl('CREATE TABLE spoc_102g_d (x integer PRIMARY KEY);');
 replicate_ddl 
---------------
 t
(1 row)

SELECT spock.repset_add_table('default', 'spoc_102g_d');
 repset_add_table 
------------------
 t
(1 row)

CREATE TABLE spoc_102l_d (x integer PRIMARY KEY);
INSERT INTO spoc_102l_d VALUES (1), (2);
INSERT INTO spoc_102g_d VALUES (-1), (-2), (-3);
SELECT spock.repset_add_table('default', 'spoc_102l_d');
 repset_add_table 
------------------
 t
(1 row)

DELETE FROM spoc_102g_d WHERE x = -1;
DELETE FROM spoc_102l_d WHERE x = 1;
DELETE FROM spoc_102g_d WHERE x = -2;
-- Check the state of replication on the subscriber node
\c :subscriber_dsn
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

SELECT * FROM spoc_102l_d ORDER BY x; -- ERROR, not existed yet.
ERROR:  relation "spoc_102l_d" does not exist at character 15
SELECT * FROM spoc_102g_d ORDER BY x; -- See one record (-3).
 x  
----
 -3
(1 row)

-- Create table where needed
\c :provider_dsn
SELECT spock.replicate_ddl('CREATE TABLE IF NOT EXISTS spoc_102l_d (x integer PRIMARY KEY)');
NOTICE:  relation "spoc_102l_d" already exists, skipping
 replicate_ddl 
---------------
 t
(1 row)

-- Do something with tables to enable replication
INSERT INTO spoc_102g_d VALUES (-4), (-5);
INSERT INTO spoc_102l_d VALUES (3), (4);
UPDATE spoc_102g_d SET x = -6 WHERE x = -4;
UPDATE spoc_102l_d SET x = 5 WHERE x = 3;
DELETE FROM spoc_102g_d WHERE x = -3 OR x = -6;
DELETE FROM spoc_102l_d WHERE x = 1 OR x = 5;
-- Check the state of replication on the subscriber node
\c :subscriber_dsn
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

SELECT * FROM spoc_102l_d ORDER BY x; -- See (4)
 x 
---
 4
(1 row)

SELECT * FROM spoc_102g_d ORDER BY x; -- See (-5).
 x  
----
 -5
(1 row)

-- Cleanup
\c :provider_dsn
SELECT spock.replicate_ddl('DROP TABLE IF EXISTS spoc_102g_d,spoc_102l_d CASCADE');
NOTICE:  drop cascades to table spoc_102g_d membership in replication set default
NOTICE:  drop cascades to table spoc_102l_d membership in replication set default
 replicate_ddl 
---------------
 t
(1 row)

