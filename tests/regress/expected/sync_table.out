/* First test whether a table's replication set can be properly manipulated */
SELECT * FROM spock_regress_variables()
\gset
--
-- Test resynchronization
--
\c :provider_dsn
SELECT spock.replicate_ddl('CREATE TABLE test_sync(x integer primary key)');
 replicate_ddl 
---------------
 t
(1 row)

SELECT * FROM spock.repset_add_table('default', 'test_sync');
 repset_add_table 
------------------
 t
(1 row)

INSERT INTO test_sync (x) SELECT value FROM generate_series(1,10) AS value;
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

SELECT sum(x), count(*) FROM test_sync;
 sum | count 
-----+-------
  55 |    10
(1 row)

\c :subscriber_dsn
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

SELECT sum(x), count(*) FROM test_sync;
 sum | count 
-----+-------
  55 |    10
(1 row)

SELECT sync_kind,sub_name,sync_nspname,sync_relname,sync_status, sync_statuslsn <> '0/0'
FROM spock.local_sync_status l JOIN spock.subscription s
  ON (l.sync_subid = s.sub_id)
ORDER BY sub_name,sync_kind,sync_nspname,sync_relname COLLATE "C";
 sync_kind |     sub_name      | sync_nspname | sync_relname | sync_status | ?column? 
-----------+-------------------+--------------+--------------+-------------+----------
 f         | test_subscription |              |              | r           | f
(1 row)

SELECT spock.sub_resync_table('test_subscription', 'test_sync', true);
 sub_resync_table 
------------------
 t
(1 row)

SELECT spock.table_wait_for_sync('test_subscription', 'test_sync');
 table_wait_for_sync 
---------------------
 
(1 row)

SELECT sum(x), count(*) FROM test_sync;
 sum | count 
-----+-------
  55 |    10
(1 row)

SELECT sync_kind,sub_name,sync_nspname,sync_relname,sync_status, sync_statuslsn <> '0/0'
FROM spock.local_sync_status l JOIN spock.subscription s
  ON (l.sync_subid = s.sub_id)
ORDER BY sub_name,sync_kind,sync_nspname,sync_relname COLLATE "C";
 sync_kind |     sub_name      | sync_nspname | sync_relname | sync_status | ?column? 
-----------+-------------------+--------------+--------------+-------------+----------
 d         | test_subscription | public       | test_sync    | r           | t
 f         | test_subscription |              |              | r           | f
(2 rows)

SELECT spock.sub_resync_table('test_subscription', 'test_sync', true);
 sub_resync_table 
------------------
 t
(1 row)

SELECT spock.table_wait_for_sync('test_subscription', 'test_sync');
 table_wait_for_sync 
---------------------
 
(1 row)

SELECT sum(x), count(*) FROM test_sync;
 sum | count 
-----+-------
  55 |    10
(1 row)

SELECT sync_kind,sub_name,sync_nspname,sync_relname,sync_status, sync_statuslsn <> '0/0'
FROM spock.local_sync_status l JOIN spock.subscription s
  ON (l.sync_subid = s.sub_id)
ORDER BY sub_name,sync_kind,sync_nspname,sync_relname COLLATE "C";
 sync_kind |     sub_name      | sync_nspname | sync_relname | sync_status | ?column? 
-----------+-------------------+--------------+--------------+-------------+----------
 d         | test_subscription | public       | test_sync    | r           | t
 f         | test_subscription |              |              | r           | f
(2 rows)

\c :provider_dsn
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

SELECT sum(x), count(*) FROM test_sync;
 sum | count 
-----+-------
  55 |    10
(1 row)

-- Add more values and check they were added
INSERT INTO test_sync (x) SELECT -value FROM generate_series(1,10) AS value;
SELECT sum(x), count(*) FROM test_sync;
 sum | count 
-----+-------
   0 |    20
(1 row)

\c :subscriber_dsn
-- Restart syncing this specific table, wait until the process finish and check
-- all the data stay consistent
SELECT sync_kind,sub_name,sync_nspname,sync_relname,sync_status, sync_statuslsn <> '0/0'
FROM spock.local_sync_status l JOIN spock.subscription s
  ON (l.sync_subid = s.sub_id)
ORDER BY sub_name,sync_kind,sync_nspname,sync_relname COLLATE "C";
 sync_kind |     sub_name      | sync_nspname | sync_relname | sync_status | ?column? 
-----------+-------------------+--------------+--------------+-------------+----------
 d         | test_subscription | public       | test_sync    | r           | t
 f         | test_subscription |              |              | r           | f
(2 rows)

SELECT spock.sub_resync_table('test_subscription', 'test_sync', true);
 sub_resync_table 
------------------
 t
(1 row)

SELECT spock.table_wait_for_sync('test_subscription', 'test_sync');
 table_wait_for_sync 
---------------------
 
(1 row)

SELECT sum(x), count(*) FROM test_sync;
 sum | count 
-----+-------
   0 |    20
(1 row)

SELECT sync_kind,sub_name,sync_nspname,sync_relname,sync_status, sync_statuslsn <> '0/0'
FROM spock.local_sync_status l JOIN spock.subscription s
  ON (l.sync_subid = s.sub_id)
ORDER BY sub_name,sync_kind,sync_nspname,sync_relname COLLATE "C";
 sync_kind |     sub_name      | sync_nspname | sync_relname | sync_status | ?column? 
-----------+-------------------+--------------+--------------+-------------+----------
 d         | test_subscription | public       | test_sync    | r           | t
 f         | test_subscription |              |              | r           | f
(2 rows)

-- Check all data still in place
\c :provider_dsn
SELECT sum(x), count(*) FROM test_sync;
 sum | count 
-----+-------
   0 |    20
(1 row)

-- Test that a TRUNCATE command also re-syncing correctly
TRUNCATE test_sync;
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

\c :subscriber_dsn
SELECT spock.sub_resync_table('test_subscription', 'test_sync', true);
 sub_resync_table 
------------------
 t
(1 row)

SELECT spock.table_wait_for_sync('test_subscription', 'test_sync');
 table_wait_for_sync 
---------------------
 
(1 row)

SELECT sum(x), count(*) FROM test_sync;
 sum | count 
-----+-------
     |     0
(1 row)

-- Generated columns
\c :provider_dsn
SELECT spock.replicate_ddl('
CREATE TABLE g1(col1 INT PRIMARY KEY, col2 INT NOT NULL, col3 int,
 col4 int generated always as (col3 + 1) stored);
');
 replicate_ddl 
---------------
 t
(1 row)

INSERT INTO g1 (col1, col2, col3) VALUES (1, 10, 100);
SELECT * FROM spock.repset_add_table('default', 'g1');
 repset_add_table 
------------------
 t
(1 row)

INSERT INTO g1 (col1, col2, col3) VALUES (2, 20, 200);
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

\c :subscriber_dsn
SELECT spock.sub_resync_table('test_subscription', 'g1', true);
 sub_resync_table 
------------------
 t
(1 row)

SELECT spock.table_wait_for_sync('test_subscription', 'g1');
 table_wait_for_sync 
---------------------
 
(1 row)

SELECT * FROM g1;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |   10 |  100 |  101
    2 |   20 |  200 |  201
(2 rows)

-- Test UPDATE and DELETE with generated columns
\c :provider_dsn
UPDATE g1 SET col3 = 150 WHERE col1 = 1;
DELETE FROM g1 WHERE col1 = 2;
INSERT INTO g1 (col1, col2, col3) VALUES (3, 30, 300);
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

\c :subscriber_dsn
SELECT * FROM g1 ORDER BY col1;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |   10 |  150 |  151
    3 |   30 |  300 |  301
(2 rows)

--
-- Test that table sync stops on error and records FAILED status
--
\c :provider_dsn
SELECT spock.replicate_ddl('CREATE TABLE test_sync_fail(x integer primary key)');
 replicate_ddl 
---------------
 t
(1 row)

SELECT * FROM spock.repset_add_table('default', 'test_sync_fail');
 repset_add_table 
------------------
 t
(1 row)

INSERT INTO test_sync_fail (x) SELECT value FROM generate_series(1,6) AS value;
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

\c :subscriber_dsn
SELECT spock.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

SELECT count(*) FROM test_sync_fail;
 count 
-------
     6
(1 row)

-- Add CHECK constraint on subscriber only. NOT VALID skips existing rows
-- but enforces on new inserts (including COPY FROM during resync).
ALTER TABLE test_sync_fail ADD CONSTRAINT chk_x CHECK (x < 5) NOT VALID;
-- Resync: COPY will fail because rows with x >= 5 violate the CHECK.
SELECT spock.sub_resync_table('test_subscription', 'test_sync_fail', true);
 sub_resync_table 
------------------
 t
(1 row)

-- table_wait_for_sync now detects FAILED status and raises ERROR.
SELECT spock.table_wait_for_sync('test_subscription', 'test_sync_fail');
ERROR:  synchronization of table public.test_sync_fail failed on subscription test_subscription
HINT:  Check the server log for details, resolve the issue, and retry.
-- Verify FAILED status in local_sync_status
SELECT sync_kind, sync_nspname, sync_relname, sync_status
FROM spock.local_sync_status
WHERE sync_nspname = 'public' AND sync_relname = 'test_sync_fail';
 sync_kind | sync_nspname |  sync_relname  | sync_status 
-----------+--------------+----------------+-------------
 d         | public       | test_sync_fail | f
(1 row)

-- Let's check exact state of the syncing table
SELECT count(*) FROM test_sync_fail;
 count 
-------
     0
(1 row)

-- Remove the problematic constraint for cleanup
ALTER TABLE test_sync_fail DROP CONSTRAINT chk_x;
-- .. and retry synchronisation.
SELECT spock.sub_resync_table('test_subscription', 'test_sync_fail', true);
 sub_resync_table 
------------------
 t
(1 row)

SELECT spock.table_wait_for_sync('test_subscription', 'test_sync_fail');
 table_wait_for_sync 
---------------------
 
(1 row)

-- Let's check exact state of the syncing table. Now, it should be OK.
SELECT sync_kind, sync_nspname, sync_relname, sync_status
FROM spock.local_sync_status
WHERE sync_nspname = 'public' AND sync_relname = 'test_sync_fail';
 sync_kind | sync_nspname |  sync_relname  | sync_status 
-----------+--------------+----------------+-------------
 d         | public       | test_sync_fail | r
(1 row)

SELECT count(*) FROM test_sync_fail;
 count 
-------
     6
(1 row)

-- Cleanup
\c :provider_dsn
DROP TABLE test_sync, g1, test_sync_fail CASCADE;
NOTICE:  drop cascades to table test_sync membership in replication set default
NOTICE:  drop cascades to table g1 membership in replication set default
NOTICE:  drop cascades to table test_sync_fail membership in replication set default
