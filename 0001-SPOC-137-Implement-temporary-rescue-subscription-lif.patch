From 80e9b31d1d977fd43b4434300046013734cb1d52 Mon Sep 17 00:00:00 2001
From: "Dr. Ibrar Ahmed" <ibrar.ahmad@gmail.com>
Date: Mon, 17 Nov 2025 20:19:57 +0500
Subject: [PATCH] SPOC-137: Implement temporary rescue subscription lifecycle
 (#263)

- Extend spock.subscription with rescue tracking fields and backfill upgrade path
- Add spock.create_rescue_subscription() to wire lagging nodes to cloned slots with skip/stop boundaries
- Teach apply worker to stop at target LSN/timestamp, persist cleanup state, and mark failures
- Let manager drop completed/failed rescue subscriptions and reuse replay_stop_lsn for controlled catch-up
- Ensure PG18 builds succeed by handling equality strategy lookup without get_equal_strategy_number_for_am()

Co-authored-by: Ibrar Ahmed <ibrar@pgedge.com>
---
 include/spock_node.h              |   9 ++
 include/spock_recovery.h          |   1 +
 sql/spock--5.0.4--6.0.0-devel.sql |  12 ++
 sql/spock--6.0.0-devel.sql        |  18 ++-
 src/spock_apply.c                 | 100 ++++++++----
 src/spock_apply_heap.c            |   2 +
 src/spock_common.c                |  11 +-
 src/spock_functions.c             |  18 ++-
 src/spock_manager.c               |  69 +++++++-
 src/spock_node.c                  | 127 ++++++++++++++-
 src/spock_recovery.c              | 258 ++++++++++++++++++++++++++++++
 11 files changed, 586 insertions(+), 39 deletions(-)

diff --git a/include/spock_node.h b/include/spock_node.h
index d7ff440..e8ff76e 100644
--- a/include/spock_node.h
+++ b/include/spock_node.h
@@ -12,6 +12,7 @@
 #ifndef SPOCK_NODE_H
 #define SPOCK_NODE_H
 
+#include "access/xlogdefs.h"
 #include "datatype/timestamp.h"
 #include "utils/jsonb.h"
 
@@ -57,6 +58,11 @@ typedef struct SpockSubscription
 	XLogRecPtr	skiplsn;	/* All changes finished at this LSN are skipped */
 	List	   *skip_schema;	/* Array of schema names to skip */
 	bool		rescue_suspended;	/* True if suspended for rescue/recovery */
+	bool		rescue_temporary;	/* True if this is a rescue-only subscription */
+	XLogRecPtr	rescue_stop_lsn;	/* Target LSN to stop replay at */
+	TimestampTz	rescue_stop_time;	/* Optional target time to stop replay */
+	bool		rescue_cleanup_pending; /* Needs cleanup (drop) after rescue */
+	bool		rescue_failed;		/* Rescue attempt failed */
 } SpockSubscription;
 
 extern void create_node(SpockNode *node);
@@ -91,5 +97,8 @@ extern void spock_suspend_subscription_for_rescue(SpockSubscription *sub);
 extern void spock_resume_subscription_post_rescue(SpockSubscription *sub);
 extern void spock_suspend_all_peer_subs_for_rescue(Oid node_id, Oid failed_node_id);
 extern void spock_resume_all_peer_subs_post_rescue(Oid node_id);
+extern void spock_set_rescue_cleanup_state(Oid subid, bool failed,
+										   XLogRecPtr reached_lsn,
+										   TimestampTz reached_ts);
 
 #endif /* SPOCK_NODE_H */
diff --git a/include/spock_recovery.h b/include/spock_recovery.h
index f141888..e07c8a2 100644
--- a/include/spock_recovery.h
+++ b/include/spock_recovery.h
@@ -90,5 +90,6 @@ extern Datum spock_find_rescue_source_sql(PG_FUNCTION_ARGS);
  * Recovery slot cloning functions
  */
 extern Datum spock_clone_recovery_slot_sql(PG_FUNCTION_ARGS);
+extern Datum spock_create_rescue_subscription_sql(PG_FUNCTION_ARGS);
 
 #endif							/* SPOCK_RECOVERY_H */
diff --git a/sql/spock--5.0.4--6.0.0-devel.sql b/sql/spock--5.0.4--6.0.0-devel.sql
index 8aa0f81..c9ee178 100644
--- a/sql/spock--5.0.4--6.0.0-devel.sql
+++ b/sql/spock--5.0.4--6.0.0-devel.sql
@@ -6,7 +6,19 @@
 DROP VIEW IF EXISTS spock.lag_tracker;
 DROP TABLE IF EXISTS spock.progress;
 
+ALTER TABLE spock.subscription
+	ADD COLUMN IF NOT EXISTS sub_rescue_temporary boolean NOT NULL DEFAULT false;
+ALTER TABLE spock.subscription
+	ADD COLUMN IF NOT EXISTS sub_rescue_stop_lsn pg_lsn;
+ALTER TABLE spock.subscription
+	ADD COLUMN IF NOT EXISTS sub_rescue_stop_time timestamptz;
+ALTER TABLE spock.subscription
+	ADD COLUMN IF NOT EXISTS sub_rescue_cleanup_pending boolean NOT NULL DEFAULT false;
+ALTER TABLE spock.subscription
+	ADD COLUMN IF NOT EXISTS sub_rescue_failed boolean NOT NULL DEFAULT false;
+
 DROP FUNCTION IF EXISTS spock.apply_group_progress;
+
 CREATE FUNCTION spock.apply_group_progress (
 	OUT dbid oid,
 	OUT node_id oid,
diff --git a/sql/spock--6.0.0-devel.sql b/sql/spock--6.0.0-devel.sql
index 629a0ad..46a4e00 100644
--- a/sql/spock--6.0.0-devel.sql
+++ b/sql/spock--6.0.0-devel.sql
@@ -36,7 +36,12 @@ CREATE TABLE spock.subscription (
     sub_force_text_transfer boolean NOT NULL DEFAULT 'f',
 	sub_skip_lsn pg_lsn NOT NULL DEFAULT '0/0',
 	sub_skip_schema text[],
-	sub_rescue_suspended boolean NOT NULL DEFAULT false
+	sub_rescue_suspended boolean NOT NULL DEFAULT false,
+	sub_rescue_temporary boolean NOT NULL DEFAULT false,
+	sub_rescue_stop_lsn pg_lsn,
+	sub_rescue_stop_time timestamptz,
+	sub_rescue_cleanup_pending boolean NOT NULL DEFAULT false,
+	sub_rescue_failed boolean NOT NULL DEFAULT false
 );
 -- Source for sub_id values.
 CREATE SEQUENCE spock.sub_id_generator AS integer MINVALUE 1 CYCLE START WITH 1 OWNED BY spock.subscription.sub_id;
@@ -681,3 +686,14 @@ RETURNS TABLE (
 )
 LANGUAGE c AS 'MODULE_PATHNAME', 'spock_clone_recovery_slot';
 
+CREATE FUNCTION spock.create_rescue_subscription(
+    target_node name,
+    source_node name,
+    cloned_slot text,
+    skip_lsn pg_lsn DEFAULT NULL,
+    stop_lsn pg_lsn DEFAULT NULL,
+    stop_timestamp timestamptz DEFAULT NULL
+)
+RETURNS oid
+LANGUAGE c AS 'MODULE_PATHNAME', 'spock_create_rescue_subscription';
+
diff --git a/src/spock_apply.c b/src/spock_apply.c
index 910d08f..172ff51 100644
--- a/src/spock_apply.c
+++ b/src/spock_apply.c
@@ -93,6 +93,7 @@ static XLogRecPtr remote_origin_lsn = InvalidXLogRecPtr;
 static RepOriginId remote_origin_id = InvalidRepOriginId;
 static TimeOffset apply_delay = 0;
 static TimestampTz required_commit_ts = 0;
+static bool rescue_cleanup_marked = false;
 
 static Oid	QueueRelid = InvalidOid;
 
@@ -249,6 +250,11 @@ static void maybe_send_feedback(PGconn *applyconn, XLogRecPtr lsn_to_send,
 static void append_feedback_position(XLogRecPtr recvpos);
 static void get_feedback_position(XLogRecPtr *recvpos, XLogRecPtr *writepos,
 								  XLogRecPtr *flushpos, XLogRecPtr *max_recvpos);
+static void mark_rescue_cleanup(bool failed, XLogRecPtr reached_lsn,
+								TimestampTz reached_ts);
+static void finish_rescue_subscription(bool failed, XLogRecPtr reached_lsn,
+									   TimestampTz reached_ts, PGconn *conn,
+									   XLogRecPtr end_lsn);
 
 /* Wrapper for latch for waiting for previous transaction to commit */
 void
@@ -910,42 +916,25 @@ handle_commit(StringInfo s)
 						(uint32) (end_lsn >> 32), (uint32) end_lsn,
 						(uint32) (MyApplyWorker->replay_stop_lsn >> 32),
 						(uint32) MyApplyWorker->replay_stop_lsn)));
+		finish_rescue_subscription(false, replorigin_session_origin_lsn,
+								   replorigin_session_origin_timestamp,
+								   applyconn, end_lsn);
+	}
 
-		/*
-		 * If this is sync worker, update syncing table state to done.
-		 */
-		if (MySpockWorker->worker_type == SPOCK_WORKER_SYNC)
-		{
-			StartTransactionCommand();
-			set_table_sync_status(MyApplyWorker->subid,
-								  NameStr(MySpockWorker->worker.sync.nspname),
-								  NameStr(MySpockWorker->worker.sync.relname),
-								  SYNC_STATUS_SYNCDONE, end_lsn);
-			CommitTransactionCommand();
-		}
-
-		/*
-		 * Flush all writes so the latest position can be reported back to the
-		 * sender.
-		 */
-		XLogFlush(GetXLogWriteRecPtr());
-
-		/*
-		 * Disconnect.
-		 *
-		 * This needs to happen before the spock_sync_worker_finish() call
-		 * otherwise slot drop will fail.
-		 */
-		PQfinish(applyconn);
+	if (MySubscription->rescue_temporary &&
+		MySubscription->rescue_stop_time != 0 &&
+		replorigin_session_origin_timestamp >= MySubscription->rescue_stop_time)
+	{
+		const char *target_ts = timestamptz_to_str(MySubscription->rescue_stop_time);
+		const char *commit_ts = timestamptz_to_str(replorigin_session_origin_timestamp);
 
-		/*
-		 * If this is sync worker, finish it.
-		 */
-		if (MySpockWorker->worker_type == SPOCK_WORKER_SYNC)
-			spock_sync_worker_finish();
+		elog(LOG,
+			 "SPOCK %s: rescue replay reached target timestamp %s (commit at %s)",
+			 MySubscription->name, target_ts, commit_ts);
 
-		/* Stop gracefully */
-		proc_exit(0);
+		finish_rescue_subscription(false, replorigin_session_origin_lsn,
+								   replorigin_session_origin_timestamp,
+								   applyconn, end_lsn);
 	}
 
 	VALGRIND_PRINTF("SPOCK_APPLY: commit %u\n", remote_xid);
@@ -2911,6 +2900,9 @@ stream_replay:
 		MemoryContextSwitchTo(MessageContext);
 		edata = CopyErrorData();
 
+		if (MySubscription && MySubscription->rescue_temporary)
+			mark_rescue_cleanup(true, InvalidXLogRecPtr, 0);
+
 		/*
 		 * use_try_block == true indicates either:
 		 * 1. An exception occurred during a DML operation,
@@ -3121,6 +3113,48 @@ clear_subscription_skip_lsn(XLogRecPtr finish_lsn)
 		CommitTransactionCommand();
 }
 
+static void
+mark_rescue_cleanup(bool failed, XLogRecPtr reached_lsn, TimestampTz reached_ts)
+{
+	if (rescue_cleanup_marked)
+		return;
+
+	if (!MySubscription || !MySubscription->rescue_temporary)
+		return;
+
+	spock_set_rescue_cleanup_state(MySubscription->id, failed,
+								   reached_lsn, reached_ts);
+	rescue_cleanup_marked = true;
+}
+
+static void
+finish_rescue_subscription(bool failed, XLogRecPtr reached_lsn,
+						   TimestampTz reached_ts, PGconn *conn,
+						   XLogRecPtr end_lsn)
+{
+	mark_rescue_cleanup(failed, reached_lsn, reached_ts);
+
+	if (MySpockWorker->worker_type == SPOCK_WORKER_SYNC)
+	{
+		StartTransactionCommand();
+		set_table_sync_status(MyApplyWorker->subid,
+							  NameStr(MySpockWorker->worker.sync.nspname),
+							  NameStr(MySpockWorker->worker.sync.relname),
+							  SYNC_STATUS_SYNCDONE, end_lsn);
+		CommitTransactionCommand();
+	}
+
+	XLogFlush(GetXLogWriteRecPtr());
+
+	if (conn)
+		PQfinish(conn);
+
+	if (MySpockWorker->worker_type == SPOCK_WORKER_SYNC)
+		spock_sync_worker_finish();
+
+	proc_exit(0);
+}
+
 /*
  * Execute an SQL command. This can be multiple multiple queries.
  */
diff --git a/src/spock_apply_heap.c b/src/spock_apply_heap.c
index d99b5ea..abb2873 100644
--- a/src/spock_apply_heap.c
+++ b/src/spock_apply_heap.c
@@ -836,8 +836,10 @@ spock_handle_conflict_and_apply(SpockRelation *rel, EState *estate,
 
 		if (is_delta_apply)
 		{
+#ifdef COMMIT_TS_SUBTRANS_TS
 			SubTransactionIdSetCommitTsData(GetCurrentTransactionId(),
 											local_ts, local_origin);
+#endif
 			ReleaseCurrentSubTransaction();
 		}
 
diff --git a/src/spock_common.c b/src/spock_common.c
index 91714a3..73ead28 100644
--- a/src/spock_common.c
+++ b/src/spock_common.c
@@ -17,6 +17,8 @@
 #include "fmgr.h"
 
 #include "executor/executor.h"
+#include "catalog/index.h"
+#include "access/hash.h"
 #include "storage/ipc.h"
 #include "storage/lmgr.h"
 #include "storage/proc.h"
@@ -426,7 +428,14 @@ spock_get_equal_strategy_number(Oid opclass)
 {
 	Oid			am = get_opclass_method(opclass);
 
-	return get_equal_strategy_number_for_am(am);
+	if (am == BTREE_AM_OID)
+		return BTEqualStrategyNumber;
+#ifdef HASH_AM_OID
+	if (am == HASH_AM_OID)
+		return HASHEqualStrategyNumber;
+#endif
+	/* Default to btree equality semantics for other AMs */
+	return BTEqualStrategyNumber;
 }
 #endif
 
diff --git a/src/spock_functions.c b/src/spock_functions.c
index ff3b8fd..fc0f3d3 100644
--- a/src/spock_functions.c
+++ b/src/spock_functions.c
@@ -168,6 +168,7 @@ PG_FUNCTION_INFO_V1(spock_max_proto_version);
 PG_FUNCTION_INFO_V1(spock_get_recovery_slot_status_sql);
 PG_FUNCTION_INFO_V1(spock_find_rescue_source);
 PG_FUNCTION_INFO_V1(spock_clone_recovery_slot);
+PG_FUNCTION_INFO_V1(spock_create_rescue_subscription);
 
 PG_FUNCTION_INFO_V1(spock_xact_commit_timestamp_origin);
 
@@ -589,6 +590,11 @@ Datum spock_create_subscription(PG_FUNCTION_ARGS)
 	else
 		sub.skip_schema = textarray_to_list(skip_schema_names);
 	sub.rescue_suspended = false;
+	sub.rescue_temporary = false;
+	sub.rescue_stop_lsn = InvalidXLogRecPtr;
+	sub.rescue_stop_time = 0;
+	sub.rescue_cleanup_pending = false;
+	sub.rescue_failed = false;
 
 	create_subscription(&sub);
 
@@ -3421,7 +3427,6 @@ spock_get_recovery_slot_status_sql(PG_FUNCTION_ARGS)
 	Datum		values[6];
 	bool		nulls[6];
 	SpockRecoverySlotData *slot;
-	char		lsn_str[32];
 
 	/* Check to see if caller supports us returning a tuplestore */
 	if (rsinfo == NULL || !IsA(rsinfo, ReturnSetInfo))
@@ -3507,3 +3512,14 @@ spock_clone_recovery_slot(PG_FUNCTION_ARGS)
     return spock_clone_recovery_slot_sql(fcinfo);
 }
 
+/*
+ * spock_create_rescue_subscription
+ *
+ * SQL-callable wrapper for creating rescue subscriptions.
+ */
+Datum
+spock_create_rescue_subscription(PG_FUNCTION_ARGS)
+{
+	return spock_create_rescue_subscription_sql(fcinfo);
+}
+
diff --git a/src/spock_manager.c b/src/spock_manager.c
index fea1885..b9fe911 100644
--- a/src/spock_manager.c
+++ b/src/spock_manager.c
@@ -18,13 +18,18 @@
 #include "commands/dbcommands.h"
 #include "commands/extension.h"
 
+#include "executor/spi.h"
+
 #include "storage/ipc.h"
 #include "storage/proc.h"
 
 #include "utils/memutils.h"
+#include "utils/builtins.h"
 #include "utils/resowner.h"
 #include "utils/timestamp.h"
 
+#include "lib/stringinfo.h"
+
 #include "pgstat.h"
 
 #include "spock_node.h"
@@ -34,6 +39,8 @@
 
 PGDLLEXPORT void spock_manager_main(Datum main_arg);
 
+static void cleanup_rescue_subscriptions(List *cleanup_list);
+
 /*
  * Suspend all peer-to-peer subscriptions during rescue between surviving nodes,
  * excluding any that touch the failed node.
@@ -70,6 +77,50 @@ spock_resume_all_peer_subs_post_rescue(Oid node_id)
 	list_free_deep(subs);
 }
 
+/*
+ * Drop temporary rescue subscriptions that have completed or failed.
+ */
+static void
+cleanup_rescue_subscriptions(List *cleanup_list)
+{
+	ListCell   *lc;
+	int			ret;
+
+	if (cleanup_list == NIL)
+		return;
+
+	ret = SPI_connect();
+	if (ret != SPI_OK_CONNECT)
+		elog(ERROR, "SPI_connect failed while cleaning rescue subscriptions");
+
+	foreach(lc, cleanup_list)
+	{
+		SpockSubscription *sub = (SpockSubscription *) lfirst(lc);
+		StringInfoData cmd;
+
+		if (!sub || !sub->name)
+			continue;
+
+		initStringInfo(&cmd);
+		appendStringInfo(&cmd,
+						 "SELECT spock.sub_drop(%s, true)",
+						 quote_literal_cstr(sub->name));
+
+		ret = SPI_execute(cmd.data, false, 0);
+		if (ret != SPI_OK_SELECT)
+			elog(WARNING,
+				 "SPOCK: failed to drop rescue subscription \"%s\" (SPI code %d)",
+				 sub->name, ret);
+		else
+			elog(LOG,
+				 "SPOCK: dropped rescue subscription \"%s\" after cleanup",
+				 sub->name);
+	}
+
+	SPI_finish();
+	list_free(cleanup_list);
+}
+
 /*
  * Manage the apply workers - start new ones, kill old ones.
  */
@@ -80,6 +131,7 @@ manage_apply_workers(void)
 	List	   *subscriptions;
 	List	   *workers;
 	List	   *subs_to_start = NIL;
+	List	   *cleanup_subs = NIL;
 	ListCell   *slc,
 			   *wlc;
 	long		ret = restart_delay_default;
@@ -105,6 +157,15 @@ manage_apply_workers(void)
 		SpockSubscription  *sub = (SpockSubscription *) lfirst(slc);
 		SpockWorker		   *apply = NULL;
 
+		if (sub->rescue_temporary)
+		{
+			if (!sub->enabled || sub->rescue_cleanup_pending)
+			{
+				cleanup_subs = lappend(cleanup_subs, sub);
+				continue;
+			}
+		}
+
 		/*
 		 * Skip if subscription not enabled.
 		 * This must be called before the following search loop because
@@ -175,6 +236,8 @@ manage_apply_workers(void)
 		subs_to_start = lappend(subs_to_start, sub);
 	}
 
+	cleanup_rescue_subscriptions(cleanup_subs);
+
 	foreach (slc, subs_to_start)
 	{
 		SpockSubscription  *sub = (SpockSubscription *) lfirst(slc);
@@ -185,7 +248,11 @@ manage_apply_workers(void)
 		apply.dboid = MySpockWorker->dboid;
 		apply.worker.apply.subid = sub->id;
 		apply.worker.apply.sync_pending = true;
-		apply.worker.apply.replay_stop_lsn = InvalidXLogRecPtr;
+		if (sub->rescue_temporary &&
+			!XLogRecPtrIsInvalid(sub->rescue_stop_lsn))
+			apply.worker.apply.replay_stop_lsn = sub->rescue_stop_lsn;
+		else
+			apply.worker.apply.replay_stop_lsn = InvalidXLogRecPtr;
 
 		spock_worker_register(&apply);
 	}
diff --git a/src/spock_node.c b/src/spock_node.c
index c41841f..a14bb0c 100644
--- a/src/spock_node.c
+++ b/src/spock_node.c
@@ -95,7 +95,7 @@ typedef struct SubscriptionTuple
 	NameData	sub_slot_name;
 } SubscriptionTuple;
 
-#define Natts_subscription			15
+#define Natts_subscription			20
 #define Anum_sub_id					1
 #define Anum_sub_name				2
 #define Anum_sub_origin				3
@@ -111,6 +111,11 @@ typedef struct SubscriptionTuple
 #define Anum_sub_skip_lsn			13
 #define Anum_sub_skip_schema		14
 #define Anum_sub_rescue_suspended	15
+#define Anum_sub_rescue_temporary	16
+#define Anum_sub_rescue_stop_lsn	17
+#define Anum_sub_rescue_stop_time	18
+#define Anum_sub_rescue_cleanup_pending 19
+#define Anum_sub_rescue_failed		20
 
 /*
  * We impose same validation rules as replication slot name validation does.
@@ -871,6 +876,22 @@ create_subscription(SpockSubscription *sub)
 		nulls[Anum_sub_skip_schema - 1] = true;
 
 	values[Anum_sub_rescue_suspended - 1] = BoolGetDatum(sub->rescue_suspended);
+	values[Anum_sub_rescue_temporary - 1] = BoolGetDatum(sub->rescue_temporary);
+
+	if (XLogRecPtrIsInvalid(sub->rescue_stop_lsn))
+		nulls[Anum_sub_rescue_stop_lsn - 1] = true;
+	else
+		values[Anum_sub_rescue_stop_lsn - 1] = LSNGetDatum(sub->rescue_stop_lsn);
+
+	if (sub->rescue_stop_time == 0)
+		nulls[Anum_sub_rescue_stop_time - 1] = true;
+	else
+		values[Anum_sub_rescue_stop_time - 1] =
+			TimestampTzGetDatum(sub->rescue_stop_time);
+
+	values[Anum_sub_rescue_cleanup_pending - 1] =
+		BoolGetDatum(sub->rescue_cleanup_pending);
+	values[Anum_sub_rescue_failed - 1] = BoolGetDatum(sub->rescue_failed);
 
 	tup = heap_form_tuple(tupDesc, values, nulls);
 
@@ -954,7 +975,10 @@ alter_subscription(SpockSubscription *sub)
 	else
 		nulls[Anum_sub_forward_origins - 1] = true;
 
-	values[Anum_sub_apply_delay - 1] = IntervalPGetDatum(sub->apply_delay);
+	if (sub->apply_delay)
+		values[Anum_sub_apply_delay - 1] = IntervalPGetDatum(sub->apply_delay);
+	else
+		nulls[Anum_sub_apply_delay - 1] = true;
 	values[Anum_sub_force_text_transfer - 1] = BoolGetDatum(sub->force_text_transfer);
 	values[Anum_sub_skip_lsn - 1] = LSNGetDatum(sub->skiplsn);
 
@@ -965,6 +989,22 @@ alter_subscription(SpockSubscription *sub)
 		nulls[Anum_sub_skip_schema - 1] = true;
 
 	values[Anum_sub_rescue_suspended - 1] = BoolGetDatum(sub->rescue_suspended);
+	values[Anum_sub_rescue_temporary - 1] = BoolGetDatum(sub->rescue_temporary);
+
+	if (XLogRecPtrIsInvalid(sub->rescue_stop_lsn))
+		nulls[Anum_sub_rescue_stop_lsn - 1] = true;
+	else
+		values[Anum_sub_rescue_stop_lsn - 1] = LSNGetDatum(sub->rescue_stop_lsn);
+
+	if (sub->rescue_stop_time == 0)
+		nulls[Anum_sub_rescue_stop_time - 1] = true;
+	else
+		values[Anum_sub_rescue_stop_time - 1] =
+			TimestampTzGetDatum(sub->rescue_stop_time);
+
+	values[Anum_sub_rescue_cleanup_pending - 1] =
+		BoolGetDatum(sub->rescue_cleanup_pending);
+	values[Anum_sub_rescue_failed - 1] = BoolGetDatum(sub->rescue_failed);
 
 	newtup = heap_modify_tuple(oldtup, tupDesc, values, nulls, replaces);
 
@@ -1035,6 +1075,11 @@ subscription_fromtuple(HeapTuple tuple, TupleDesc desc)
 	sub->slot_name = pstrdup(NameStr(subtup->sub_slot_name));
 	sub->skip_schema = NIL;  /* Initialize to avoid memory corruption */
 	sub->rescue_suspended = false;  /* Initialize, will be set from catalog */
+	sub->rescue_temporary = false;
+	sub->rescue_stop_lsn = InvalidXLogRecPtr;
+	sub->rescue_stop_time = 0;
+	sub->rescue_cleanup_pending = false;
+	sub->rescue_failed = false;
 
 	sub->origin = get_node(subtup->sub_origin);
 	sub->target = get_node(subtup->sub_target);
@@ -1102,6 +1147,31 @@ subscription_fromtuple(HeapTuple tuple, TupleDesc desc)
 	else
 		sub->rescue_suspended = DatumGetBool(d);
 
+	/* Get rescue_temporary. */
+	d = heap_getattr(tuple, Anum_sub_rescue_temporary, desc, &isnull);
+	if (!isnull)
+		sub->rescue_temporary = DatumGetBool(d);
+
+	/* Get rescue_stop_lsn. */
+	d = heap_getattr(tuple, Anum_sub_rescue_stop_lsn, desc, &isnull);
+	if (!isnull)
+		sub->rescue_stop_lsn = DatumGetLSN(d);
+
+	/* Get rescue_stop_time. */
+	d = heap_getattr(tuple, Anum_sub_rescue_stop_time, desc, &isnull);
+	if (!isnull)
+		sub->rescue_stop_time = DatumGetTimestampTz(d);
+
+	/* Get rescue_cleanup_pending. */
+	d = heap_getattr(tuple, Anum_sub_rescue_cleanup_pending, desc, &isnull);
+	if (!isnull)
+		sub->rescue_cleanup_pending = DatumGetBool(d);
+
+	/* Get rescue_failed. */
+	d = heap_getattr(tuple, Anum_sub_rescue_failed, desc, &isnull);
+	if (!isnull)
+		sub->rescue_failed = DatumGetBool(d);
+
 	return sub;
 }
 
@@ -1303,3 +1373,56 @@ spock_resume_subscription_post_rescue(SpockSubscription *sub)
 		 "SPOCK: Resumed subscription '%s' after rescue/recovery (id %u)",
 		 sub->name, sub->id);
 }
+
+/*
+ * spock_set_rescue_cleanup_state
+ *   Mark a rescue subscription as pending cleanup after success/failure.
+ *
+ * This disables the subscription to prevent worker restarts, persists any
+ * reached LSN/timestamp, and records whether cleanup is due to failure.
+ */
+void
+spock_set_rescue_cleanup_state(Oid subid, bool failed,
+							   XLogRecPtr reached_lsn,
+							   TimestampTz reached_ts)
+{
+	SpockSubscription *sub;
+	bool		started_tx = false;
+
+	if (!OidIsValid(subid))
+		return;
+
+	if (!IsTransactionState())
+	{
+		StartTransactionCommand();
+		started_tx = true;
+	}
+
+	sub = get_subscription(subid);
+
+	if (!sub->rescue_temporary)
+	{
+		if (started_tx)
+			CommitTransactionCommand();
+		return;
+	}
+
+	sub->enabled = false;
+	sub->rescue_cleanup_pending = true;
+	sub->rescue_failed = failed;
+
+	if (!XLogRecPtrIsInvalid(reached_lsn))
+		sub->rescue_stop_lsn = reached_lsn;
+
+	if (reached_ts != 0)
+		sub->rescue_stop_time = reached_ts;
+
+	alter_subscription(sub);
+
+	elog(LOG,
+		 "SPOCK: Marked rescue subscription '%s' (id %u) for cleanup (failed=%s)",
+		 sub->name, sub->id, failed ? "true" : "false");
+
+	if (started_tx)
+		CommitTransactionCommand();
+}
diff --git a/src/spock_recovery.c b/src/spock_recovery.c
index 9360431..e968fbc 100644
--- a/src/spock_recovery.c
+++ b/src/spock_recovery.c
@@ -42,6 +42,7 @@
 #include "executor/spi.h"
 #include "funcapi.h"
 #include "libpq-fe.h"
+#include "lib/stringinfo.h"
 #include "miscadmin.h"
 #include "replication/slot.h"
 #include "storage/ipc.h"
@@ -57,7 +58,9 @@
 #include "spock.h"
 #include "spock_common.h"
 #include "spock_node.h"
+#include "spock_group.h"
 #include "spock_recovery.h"
+#include "spock_sync.h"
 
 /* Global recovery coordinator in shared memory */
 SpockRecoveryCoordinator *SpockRecoveryCtx = NULL;
@@ -68,6 +71,9 @@ SpockRecoveryCoordinator *SpockRecoveryCtx = NULL;
 static SpockRecoverySlotData *get_recovery_slot(void);
 static void initialize_recovery_slot(SpockRecoverySlotData *slot,
 									 const char *database_name);
+static void append_sanitized_token(StringInfo buf, const char *token);
+static char *build_rescue_subscription_name(const char *target, const char *source);
+static void validate_rescue_slot_name(const char *slot_name);
 
 /*
  * spock_recovery_shmem_size
@@ -241,6 +247,97 @@ initialize_recovery_slot(SpockRecoverySlotData *slot,
 	pg_atomic_add_fetch_u32(&slot->recovery_generation, 1);
 }
 
+/*
+ * Helper to sanitize node names into subscription-safe tokens.
+ */
+static void
+append_sanitized_token(StringInfo buf, const char *token)
+{
+	int			i;
+
+	if (token == NULL || token[0] == '\0')
+	{
+		appendStringInfoString(buf, "unknown");
+		return;
+	}
+
+	for (i = 0; token[i] != '\0'; i++)
+	{
+		unsigned char c = (unsigned char) token[i];
+
+		if (c >= 'A' && c <= 'Z')
+			appendStringInfoChar(buf, (char) tolower(c));
+		else if ((c >= 'a' && c <= 'z') ||
+				 (c >= '0' && c <= '9'))
+			appendStringInfoChar(buf, (char) c);
+		else if (c == '_')
+			appendStringInfoChar(buf, '_');
+		else
+			appendStringInfoChar(buf, '_');
+	}
+}
+
+/*
+ * Build deterministic subscription name for rescue subscriptions.
+ */
+static char *
+build_rescue_subscription_name(const char *target, const char *source)
+{
+	StringInfoData buf;
+
+	initStringInfo(&buf);
+	appendStringInfoString(&buf, "spock_rescue_sub_");
+	append_sanitized_token(&buf, target);
+	appendStringInfoChar(&buf, '_');
+	append_sanitized_token(&buf, source);
+
+	if (buf.len >= NAMEDATALEN)
+		ereport(ERROR,
+				(errcode(ERRCODE_NAME_TOO_LONG),
+				 errmsg("generated rescue subscription name \"%s\" is too long",
+						buf.data)));
+
+	return buf.data;
+}
+
+/*
+ * Validate cloned slot name for rescue subscription.
+ */
+static void
+validate_rescue_slot_name(const char *slot_name)
+{
+	size_t		len;
+	int			i;
+
+	if (slot_name == NULL || slot_name[0] == '\0')
+		ereport(ERROR,
+				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+				 errmsg("cloned slot name must not be empty")));
+
+	len = strlen(slot_name);
+	if (len >= NAMEDATALEN)
+		ereport(ERROR,
+				(errcode(ERRCODE_NAME_TOO_LONG),
+				 errmsg("cloned slot name \"%s\" is too long", slot_name)));
+
+	for (i = 0; slot_name[i] != '\0'; i++)
+	{
+		unsigned char c = (unsigned char) slot_name[i];
+
+		if ((c >= 'a' && c <= 'z') ||
+			(c >= '0' && c <= '9') ||
+			c == '_')
+			continue;
+
+		ereport(ERROR,
+				(errcode(ERRCODE_INVALID_NAME),
+				 errmsg("cloned slot name \"%s\" contains invalid character \"%c\"",
+						slot_name, slot_name[i]),
+				 errhint("Slot names may only contain lower case letters, "
+						 "numbers, and the underscore character.")));
+	}
+}
+
 /*
  * create_recovery_slot
  *
@@ -947,3 +1044,164 @@ cleanup:
 
 	PG_RETURN_DATUM(HeapTupleGetDatum(tuple));
 }
+
+/*
+ * spock_create_rescue_subscription_sql
+ *
+ * Create a temporary rescue subscription from the current (lagging) node to a
+ * cloned recovery slot on a more advanced peer. The subscription uses the
+ * cloned slot, optionally skips already processed transactions, and stops at a
+ * known-safe LSN/timestamp to allow automatic cleanup.
+ */
+Datum
+spock_create_rescue_subscription_sql(PG_FUNCTION_ARGS)
+{
+	Name		target_name = PG_GETARG_NAME(0);
+	Name		source_name = PG_GETARG_NAME(1);
+	char	   *cloned_slot_name = text_to_cstring(PG_GETARG_TEXT_PP(2));
+	XLogRecPtr	skip_lsn = PG_ARGISNULL(3) ? InvalidXLogRecPtr : PG_GETARG_LSN(3);
+	XLogRecPtr	stop_lsn = PG_ARGISNULL(4) ? InvalidXLogRecPtr : PG_GETARG_LSN(4);
+	TimestampTz	stop_timestamp = PG_ARGISNULL(5) ? 0 : PG_GETARG_TIMESTAMPTZ(5);
+	SpockLocalNode *localnode;
+	SpockNode  *origin;
+	SpockInterface *originif;
+	SpockInterface	targetif;
+	SpockSubscription sub;
+	SpockSyncStatus sync;
+	List	   *repsets = NIL;
+	Interval   *apply_delay;
+	char	   *sub_name = NULL;
+	Oid			subid = InvalidOid;
+	bool		sub_created = false;
+
+	/* Require at least one stopping condition (LSN or timestamp). */
+	if (XLogRecPtrIsInvalid(stop_lsn) && stop_timestamp == 0)
+		ereport(ERROR,
+				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+				 errmsg("rescue subscription requires stop LSN or stop timestamp"),
+				 errdetail("Provide stop_lsn, stop_timestamp, or both.")));
+
+	if (!XLogRecPtrIsInvalid(skip_lsn) && !XLogRecPtrIsInvalid(stop_lsn) &&
+		skip_lsn >= stop_lsn)
+		ereport(ERROR,
+				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+				 errmsg("skip LSN must be lower than stop LSN"),
+				 errdetail("Provided skip_lsn %X/%X is not less than stop_lsn %X/%X."),
+				 LSN_FORMAT_ARGS(skip_lsn), LSN_FORMAT_ARGS(stop_lsn)));
+
+	validate_rescue_slot_name(cloned_slot_name);
+
+	localnode = get_local_node(true, false);
+	if (!localnode || !localnode->node || !localnode->node_if)
+		elog(ERROR, "local node not initialized");
+
+	if (strcmp(NameStr(*target_name), localnode->node->name) != 0)
+		ereport(ERROR,
+				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+				 errmsg("target node \"%s\" does not match local node \"%s\"",
+						NameStr(*target_name), localnode->node->name)));
+
+	origin = get_node_by_name(NameStr(*source_name), false);
+
+	originif = get_node_interface_by_name(origin->id, "default", true);
+	if (originif == NULL)
+		originif = get_node_interface_by_name(origin->id, origin->name, false);
+
+	/* Verify connectivity to provider node. */
+	PG_TRY();
+	{
+		PGconn *conn = spock_connect(originif->dsn, "rescue_sub", "create");
+		PQfinish(conn);
+
+		conn = spock_connect_replica(originif->dsn, "rescue_sub", "create");
+		PQfinish(conn);
+	}
+	PG_CATCH();
+	{
+		FlushErrorState();
+		ereport(ERROR,
+				(errcode(ERRCODE_CONNECTION_FAILURE),
+				 errmsg("failed to connect to provider DSN \"%s\"", originif->dsn),
+				 errhint("Verify network connectivity and authentication.")));
+	}
+	PG_END_TRY();
+
+	sub_name = build_rescue_subscription_name(localnode->node->name,
+											  NameStr(*source_name));
+
+	memset(&sub, 0, sizeof(SpockSubscription));
+	sub.id = InvalidOid;
+	sub.name = sub_name;
+	sub.origin_if = originif;
+
+	targetif.id = localnode->node_if->id;
+	targetif.name = localnode->node_if->name;
+	targetif.nodeid = localnode->node->id;
+	targetif.dsn = localnode->node_if->dsn;
+	sub.target_if = &targetif;
+
+	sub.enabled = true;
+	sub.slot_name = pstrdup(cloned_slot_name);
+
+	repsets = lappend(repsets, pstrdup("default"));
+	repsets = lappend(repsets, pstrdup("default_insert_only"));
+	repsets = lappend(repsets, pstrdup("ddl_sql"));
+	sub.replication_sets = repsets;
+	sub.forward_origins = NIL;
+
+	apply_delay = (Interval *) palloc0(sizeof(Interval));
+	sub.apply_delay = apply_delay;
+	sub.force_text_transfer = false;
+	sub.skiplsn = skip_lsn;
+	sub.skip_schema = NIL;
+	sub.rescue_suspended = false;
+	sub.rescue_temporary = true;
+	sub.rescue_stop_lsn = stop_lsn;
+	sub.rescue_stop_time = stop_timestamp;
+	sub.rescue_cleanup_pending = false;
+	sub.rescue_failed = false;
+
+	PG_TRY();
+	{
+		create_subscription(&sub);
+		sub_created = true;
+		subid = sub.id;
+
+		spock_group_attach(MyDatabaseId, localnode->node->id,
+						   originif->nodeid, NULL);
+
+		memset(&sync, 0, sizeof(SpockSyncStatus));
+		sync.kind = SYNC_KIND_INIT;
+		sync.subid = sub.id;
+		sync.status = SYNC_STATUS_INIT;
+		create_local_sync_status(&sync);
+	}
+	PG_CATCH();
+	{
+		ErrorData *edata = CopyErrorData();
+
+		if (sub_created && OidIsValid(subid))
+		{
+			PG_TRY();
+			{
+				drop_subscription_sync_status(subid);
+				drop_subscription(subid);
+			}
+			PG_CATCH();
+			{
+				FlushErrorState();
+			}
+			PG_END_TRY();
+		}
+
+		FlushErrorState();
+		ReThrowError(edata);
+	}
+	PG_END_TRY();
+
+	elog(LOG,
+		 "SPOCK: created rescue subscription \"%s\" (id %u) using slot \"%s\"",
+		 sub_name, sub.id, cloned_slot_name);
+
+	PG_RETURN_OID(sub.id);
+}
-- 
2.52.0

